package io.aurigraph.v11.unit;

import io.aurigraph.v11.contracts.models.AssetType;
import io.aurigraph.v11.tokens.TokenManagementService;
import io.aurigraph.v11.tokens.TokenManagementService.*;
import io.aurigraph.v11.tokens.TokenRepository;
import io.aurigraph.v11.tokens.TokenBalanceRepository;
import io.aurigraph.v11.tokens.models.Token;
import io.aurigraph.v11.tokens.models.TokenBalance;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.InjectMock;
import jakarta.inject.Inject;
import org.junit.jupiter.api.*;
import org.mockito.ArgumentCaptor;

import java.math.BigDecimal;
import java.time.Duration;
import java.time.Instant;
import java.util.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Comprehensive unit tests for TokenManagementService
 *
 * Tests token lifecycle with mocked dependencies:
 * - Mint operations with balance tracking
 * - Burn operations with supply updates
 * - Transfer operations with dual balance updates
 * - Query operations (balance, supply, holders)
 * - RWA token creation and asset tokenization
 * - Statistics and metrics tracking
 * - Error handling and edge cases
 *
 * Coverage Target: 95% line, 90% branch (Phase 4 Critical Package)
 *
 * @version 3.10.0 (Phase 4 Day 3-4)
 */
@QuarkusTest
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class TokenManagementServiceTest {

    @Inject
    TokenManagementService tokenService;

    @InjectMock
    TokenRepository tokenRepository;

    @InjectMock
    TokenBalanceRepository balanceRepository;

    private Token testToken;
    private TokenBalance testBalance;

    private static final String TEST_TOKEN_ID = "token-123";
    private static final String TEST_ADDRESS = "0xAddress123";
    private static final String TEST_ADDRESS_2 = "0xAddress456";

    @BeforeEach
    void setUp() {
        // Create test token
        testToken = new Token();
        testToken.setTokenId(TEST_TOKEN_ID);
        testToken.setName("TestToken");
        testToken.setSymbol("TST");
        testToken.setDecimals(18);
        testToken.setTotalSupply(new BigDecimal("1000000"));
        testToken.setCirculatingSupply(new BigDecimal("500000"));
        testToken.setBurnedAmount(BigDecimal.ZERO);
        testToken.setMaxSupply(new BigDecimal("10000000"));
        testToken.setIsPaused(false);
        testToken.setTransferCount(0L);
        testToken.setHolderCount(0L);

        // Create test balance
        testBalance = new TokenBalance(TEST_TOKEN_ID, TEST_ADDRESS, new BigDecimal("1000"));
    }

    // ==================== MINT OPERATIONS ====================

    @Test
    @Order(1)
    @DisplayName("UT-TMS-01: Should mint tokens successfully")
    void testMintTokenSuccess() {
        // Arrange
        MintRequest request = new MintRequest(TEST_TOKEN_ID, TEST_ADDRESS, new BigDecimal("500"));

        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS))
                .thenReturn(Optional.of(testBalance));
        when(balanceRepository.countHolders(TEST_TOKEN_ID)).thenReturn(1L);

        // Act
        MintResult result = tokenService.mintToken(request)
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.tokenId()).isEqualTo(TEST_TOKEN_ID);
        assertThat(result.toAddress()).isEqualTo(TEST_ADDRESS);
        assertThat(result.amount()).isEqualByComparingTo(new BigDecimal("500"));
        assertThat(result.transactionHash()).isNotNull();

        // Verify repository interactions
        verify(tokenRepository, times(1)).findByTokenId(TEST_TOKEN_ID);
        verify(tokenRepository, times(2)).persist(testToken); // Once for mint, once for holder count
        verify(balanceRepository, times(1)).persist(any(TokenBalance.class));
    }

    @Test
    @Order(2)
    @DisplayName("UT-TMS-02: Should create new balance when minting to new address")
    void testMintTokenNewAddress() {
        // Arrange
        MintRequest request = new MintRequest(TEST_TOKEN_ID, TEST_ADDRESS_2, new BigDecimal("100"));

        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS_2))
                .thenReturn(Optional.empty());
        when(balanceRepository.countHolders(TEST_TOKEN_ID)).thenReturn(2L);

        // Act
        MintResult result = tokenService.mintToken(request)
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.toAddress()).isEqualTo(TEST_ADDRESS_2);

        // Verify new balance was created and persisted
        ArgumentCaptor<TokenBalance> balanceCaptor = ArgumentCaptor.forClass(TokenBalance.class);
        verify(balanceRepository, times(1)).persist(balanceCaptor.capture());

        TokenBalance capturedBalance = balanceCaptor.getValue();
        assertThat(capturedBalance.getAddress()).isEqualTo(TEST_ADDRESS_2);
    }

    @Test
    @Order(3)
    @DisplayName("UT-TMS-03: Should throw exception when minting non-existent token")
    void testMintTokenNotFound() {
        // Arrange
        MintRequest request = new MintRequest("invalid-token", TEST_ADDRESS, new BigDecimal("100"));
        when(tokenRepository.findByTokenId("invalid-token")).thenReturn(Optional.empty());

        // Act & Assert
        assertThatThrownBy(() ->
                tokenService.mintToken(request)
                        .await().atMost(Duration.ofSeconds(5))
        ).isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Token not found");

        verify(tokenRepository, times(1)).findByTokenId("invalid-token");
        verify(tokenRepository, never()).persist(any());
    }

    // ==================== BURN OPERATIONS ====================

    @Test
    @Order(4)
    @DisplayName("UT-TMS-04: Should burn tokens successfully")
    void testBurnTokenSuccess() {
        // Arrange
        BurnRequest request = new BurnRequest(TEST_TOKEN_ID, TEST_ADDRESS, new BigDecimal("200"));

        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS))
                .thenReturn(Optional.of(testBalance));
        when(balanceRepository.countHolders(TEST_TOKEN_ID)).thenReturn(1L);

        // Act
        BurnResult result = tokenService.burnToken(request)
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.tokenId()).isEqualTo(TEST_TOKEN_ID);
        assertThat(result.fromAddress()).isEqualTo(TEST_ADDRESS);
        assertThat(result.amount()).isEqualByComparingTo(new BigDecimal("200"));
        assertThat(result.transactionHash()).isNotNull();

        verify(tokenRepository, times(1)).findByTokenId(TEST_TOKEN_ID);
        verify(balanceRepository, times(1)).persist(any(TokenBalance.class));
        verify(tokenRepository, times(2)).persist(testToken);
    }

    @Test
    @Order(5)
    @DisplayName("UT-TMS-05: Should throw exception when burning from non-existent balance")
    void testBurnTokenNoBalance() {
        // Arrange
        BurnRequest request = new BurnRequest(TEST_TOKEN_ID, TEST_ADDRESS_2, new BigDecimal("100"));

        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS_2))
                .thenReturn(Optional.empty());

        // Act & Assert
        assertThatThrownBy(() ->
                tokenService.burnToken(request)
                        .await().atMost(Duration.ofSeconds(5))
        ).isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Balance not found");

        verify(balanceRepository, never()).persist(any());
    }

    // ==================== TRANSFER OPERATIONS ====================

    @Test
    @Order(6)
    @DisplayName("UT-TMS-06: Should transfer tokens successfully")
    void testTransferTokenSuccess() {
        // Arrange
        TransferRequest request = new TransferRequest(TEST_TOKEN_ID, TEST_ADDRESS, TEST_ADDRESS_2,
                new BigDecimal("300"));

        TokenBalance senderBalance = new TokenBalance(TEST_TOKEN_ID, TEST_ADDRESS, new BigDecimal("1000"));
        TokenBalance receiverBalance = new TokenBalance(TEST_TOKEN_ID, TEST_ADDRESS_2, new BigDecimal("500"));

        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS))
                .thenReturn(Optional.of(senderBalance));
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS_2))
                .thenReturn(Optional.of(receiverBalance));
        when(balanceRepository.countHolders(TEST_TOKEN_ID)).thenReturn(2L);

        // Act
        TransferResult result = tokenService.transferToken(request)
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.tokenId()).isEqualTo(TEST_TOKEN_ID);
        assertThat(result.fromAddress()).isEqualTo(TEST_ADDRESS);
        assertThat(result.toAddress()).isEqualTo(TEST_ADDRESS_2);
        assertThat(result.amount()).isEqualByComparingTo(new BigDecimal("300"));
        assertThat(result.transactionHash()).isNotNull();

        verify(balanceRepository, atLeast(1)).persist(any(TokenBalance.class));
        verify(tokenRepository, atLeast(1)).persist(testToken);
    }

    @Test
    @Order(7)
    @DisplayName("UT-TMS-07: Should create receiver balance if it doesn't exist")
    void testTransferTokenNewReceiver() {
        // Arrange
        TransferRequest request = new TransferRequest(TEST_TOKEN_ID, TEST_ADDRESS, TEST_ADDRESS_2,
                new BigDecimal("100"));

        TokenBalance senderBalance = new TokenBalance(TEST_TOKEN_ID, TEST_ADDRESS, new BigDecimal("1000"));

        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS))
                .thenReturn(Optional.of(senderBalance));
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS_2))
                .thenReturn(Optional.empty()); // No existing balance
        when(balanceRepository.countHolders(TEST_TOKEN_ID)).thenReturn(2L);

        // Act
        TransferResult result = tokenService.transferToken(request)
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(result).isNotNull();
        verify(balanceRepository, times(2)).persist(any(TokenBalance.class));
    }

    @Test
    @Order(8)
    @DisplayName("UT-TMS-08: Should throw exception when transferring paused token")
    void testTransferTokenPaused() {
        // Arrange
        testToken.setIsPaused(true);
        TransferRequest request = new TransferRequest(TEST_TOKEN_ID, TEST_ADDRESS, TEST_ADDRESS_2,
                new BigDecimal("100"));

        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));

        // Act & Assert
        assertThatThrownBy(() ->
                tokenService.transferToken(request)
                        .await().atMost(Duration.ofSeconds(5))
        ).isInstanceOf(IllegalStateException.class)
                .hasMessageContaining("Token is paused");

        verify(balanceRepository, never()).persist(any());
    }

    @Test
    @Order(9)
    @DisplayName("UT-TMS-09: Should throw exception when sender has no balance")
    void testTransferTokenNoSenderBalance() {
        // Arrange
        TransferRequest request = new TransferRequest(TEST_TOKEN_ID, TEST_ADDRESS, TEST_ADDRESS_2,
                new BigDecimal("100"));

        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS))
                .thenReturn(Optional.empty());

        // Act & Assert
        assertThatThrownBy(() ->
                tokenService.transferToken(request)
                        .await().atMost(Duration.ofSeconds(5))
        ).isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Sender balance not found");

        verify(balanceRepository, never()).persist(any());
    }

    // ==================== QUERY OPERATIONS ====================

    @Test
    @Order(10)
    @DisplayName("UT-TMS-10: Should get token balance")
    void testGetBalance() {
        // Arrange
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS))
                .thenReturn(Optional.of(testBalance));

        // Act
        BigDecimal balance = tokenService.getBalance(TEST_ADDRESS, TEST_TOKEN_ID)
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(balance).isEqualByComparingTo(new BigDecimal("1000"));
        verify(balanceRepository, times(1)).findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS);
    }

    @Test
    @Order(11)
    @DisplayName("UT-TMS-11: Should return zero for non-existent balance")
    void testGetBalanceNotFound() {
        // Arrange
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS_2))
                .thenReturn(Optional.empty());

        // Act
        BigDecimal balance = tokenService.getBalance(TEST_ADDRESS_2, TEST_TOKEN_ID)
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(balance).isEqualByComparingTo(BigDecimal.ZERO);
    }

    @Test
    @Order(12)
    @DisplayName("UT-TMS-12: Should get total token supply")
    void testGetTotalSupply() {
        // Arrange
        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));

        // Act
        TokenSupply supply = tokenService.getTotalSupply(TEST_TOKEN_ID)
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(supply).isNotNull();
        assertThat(supply.tokenId()).isEqualTo(TEST_TOKEN_ID);
        assertThat(supply.totalSupply()).isEqualByComparingTo(new BigDecimal("1000000"));
        assertThat(supply.circulatingSupply()).isEqualByComparingTo(new BigDecimal("500000"));
        assertThat(supply.maxSupply()).isEqualByComparingTo(new BigDecimal("10000000"));
    }

    @Test
    @Order(13)
    @DisplayName("UT-TMS-13: Should get token holders")
    void testGetTokenHolders() {
        // Arrange
        List<TokenBalance> balances = Arrays.asList(
                new TokenBalance(TEST_TOKEN_ID, TEST_ADDRESS, new BigDecimal("1000")),
                new TokenBalance(TEST_TOKEN_ID, TEST_ADDRESS_2, new BigDecimal("500"))
        );

        when(balanceRepository.findTopHolders(TEST_TOKEN_ID, 10)).thenReturn(balances);
        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));

        // Act
        List<TokenHolder> holders = tokenService.getTokenHolders(TEST_TOKEN_ID, 10)
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(holders).hasSize(2);
        assertThat(holders.get(0).address()).isEqualTo(TEST_ADDRESS);
        assertThat(holders.get(0).balance()).isEqualByComparingTo(new BigDecimal("1000"));
        assertThat(holders.get(1).address()).isEqualTo(TEST_ADDRESS_2);
        assertThat(holders.get(1).balance()).isEqualByComparingTo(new BigDecimal("500"));
    }

    // ==================== RWA TOKEN OPERATIONS ====================

    @Test
    @Order(14)
    @DisplayName("UT-TMS-14: Should create RWA token")
    void testCreateRWAToken() {
        // Arrange
        RWATokenRequest request = new RWATokenRequest(
                "RealEstateToken",
                "RET",
                "0xOwner",
                new BigDecimal("1000000"),
                18,
                AssetType.REAL_ESTATE,
                "PROPERTY-001",
                new BigDecimal("500000.00"),
                "USD",
                false,
                false,
                new BigDecimal("1000000"),
                true
        );

        Token expectedToken = new Token();
        expectedToken.setTokenId("rwa-token-123");
        expectedToken.setName("RealEstateToken");
        expectedToken.setSymbol("RET");
        expectedToken.setIsRWA(true);

        doAnswer(invocation -> {
            Token token = invocation.getArgument(0);
            token.setTokenId("rwa-token-123");
            return null;
        }).when(tokenRepository).persist(any(Token.class));

        // Act & Assert
        assertThatNoException().isThrownBy(() -> {
            Token result = tokenService.createRWAToken(request)
                    .await().atMost(Duration.ofSeconds(5));
            assertThat(result).isNotNull();
        });

        verify(tokenRepository, atLeastOnce()).persist(any(Token.class));
    }

    @Test
    @Order(15)
    @DisplayName("UT-TMS-15: Should tokenize asset")
    void testTokenizeAsset() {
        // Arrange
        AssetTokenizationRequest request = new AssetTokenizationRequest(
                "ArtworkToken",
                "ART",
                "0xArtist",
                new BigDecimal("1000"),
                AssetType.ARTWORK,
                "artwork-001",
                new BigDecimal("100000.00"),
                "USD",
                false,
                false,
                new BigDecimal("1000"),
                false
        );

        doAnswer(invocation -> {
            Token token = invocation.getArgument(0);
            token.setTokenId("asset-token-123");
            return null;
        }).when(tokenRepository).persist(any(Token.class));

        // Act & Assert
        assertThatNoException().isThrownBy(() -> {
            Token result = tokenService.tokenizeAsset(request)
                    .await().atMost(Duration.ofSeconds(5));
            assertThat(result).isNotNull();
        });

        verify(tokenRepository, atLeastOnce()).persist(any(Token.class));
    }

    // ==================== TOKEN RETRIEVAL ====================

    @Test
    @Order(16)
    @DisplayName("UT-TMS-16: Should get token by ID")
    void testGetToken() {
        // Arrange
        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));

        // Act
        Token result = tokenService.getToken(TEST_TOKEN_ID)
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getTokenId()).isEqualTo(TEST_TOKEN_ID);
        assertThat(result.getSymbol()).isEqualTo("TST");
    }

    @Test
    @Order(17)
    @DisplayName("UT-TMS-17: Should throw exception for non-existent token")
    void testGetTokenNotFound() {
        // Arrange
        when(tokenRepository.findByTokenId("invalid-token")).thenReturn(Optional.empty());

        // Act & Assert
        assertThatThrownBy(() ->
                tokenService.getToken("invalid-token")
                        .await().atMost(Duration.ofSeconds(5))
        ).isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Token not found");
    }

    @Test
    @Order(18)
    @DisplayName("UT-TMS-18: Should list tokens with pagination")
    void testListTokens() {
        // Act - Just verify method doesn't throw exceptions
        // Repository mocking for findAll().page().list() is complex, so just verify execution
        assertThatNoException().isThrownBy(() -> {
            List<Token> result = tokenService.listTokens(0, 10)
                    .await().atMost(Duration.ofSeconds(5));
            assertThat(result).isNotNull();
        });
    }

    // ==================== STATISTICS ====================

    @Test
    @Order(19)
    @DisplayName("UT-TMS-19: Should get service statistics")
    void testGetStatistics() {
        // Arrange
        when(tokenRepository.count()).thenReturn(10L);
        when(balanceRepository.count()).thenReturn(50L);

        // Act
        Map<String, Object> stats = tokenService.getStatistics()
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(stats).isNotNull();
        assertThat(stats).containsKeys("totalTokens", "totalBalances", "tokensMinted",
                "tokensBurned", "transfersCompleted", "rwaTokensCreated");
        assertThat(stats.get("totalTokens")).isEqualTo(10L);
        assertThat(stats.get("totalBalances")).isEqualTo(50L);
    }

    // ==================== EDGE CASES ====================

    @Test
    @Order(20)
    @DisplayName("UT-TMS-20: Should handle zero amount transfers gracefully")
    void testZeroAmountTransfer() {
        // Arrange
        TransferRequest request = new TransferRequest(TEST_TOKEN_ID, TEST_ADDRESS, TEST_ADDRESS_2,
                BigDecimal.ZERO);

        TokenBalance senderBalance = new TokenBalance(TEST_TOKEN_ID, TEST_ADDRESS, new BigDecimal("1000"));
        TokenBalance receiverBalance = new TokenBalance(TEST_TOKEN_ID, TEST_ADDRESS_2, new BigDecimal("500"));

        when(tokenRepository.findByTokenId(TEST_TOKEN_ID)).thenReturn(Optional.of(testToken));
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS))
                .thenReturn(Optional.of(senderBalance));
        when(balanceRepository.findByTokenAndAddress(TEST_TOKEN_ID, TEST_ADDRESS_2))
                .thenReturn(Optional.of(receiverBalance));
        when(balanceRepository.countHolders(TEST_TOKEN_ID)).thenReturn(2L);

        // Act
        TransferResult result = tokenService.transferToken(request)
                .await().atMost(Duration.ofSeconds(5));

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.amount()).isEqualByComparingTo(BigDecimal.ZERO);
    }
}
