name: JIRA Ticket Synchronization - Aurigraph V11

on:
  push:
    branches: [ main, 'feature/aurigraph-v11-*', 'sprint/*' ]
  pull_request:
    types: [opened, closed, reopened, synchronize]
  issues:
    types: [opened, closed, reopened, labeled]
  workflow_dispatch:
    inputs:
      sync_action:
        description: 'Synchronization Action'
        required: true
        default: 'sync_all'
        type: choice
        options:
          - sync_all
          - create_tickets
          - update_status
          - close_completed
      ticket_filter:
        description: 'Ticket Filter (optional)'
        required: false
        default: 'AV11-*'

env:
  JIRA_BASE_URL: "https://aurigraphdlt.atlassian.net"
  JIRA_PROJECT_KEY: "AV11"
  JIRA_EMAIL: "subbu@aurigraphdlt.com"

jobs:
  sync-tickets:
    runs-on: ubuntu-latest
    name: Sync JIRA Tickets
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install Dependencies
      run: |
        npm install axios @actions/core @actions/github
        
    - name: Extract Commit Information
      id: commit-info
      run: |
        # Extract JIRA ticket references from commits
        TICKET_REFS=$(git log --since="24 hours ago" --grep="AV11-" --oneline | grep -oE "AV11-[0-9]+" | sort -u)
        COMMIT_COUNT=$(git log --since="24 hours ago" --oneline | wc -l)
        
        echo "ticket_refs<<EOF" >> $GITHUB_OUTPUT
        echo "$TICKET_REFS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
        
        # Extract agent mentions from commits
        AGENT_MENTIONS=$(git log --since="24 hours ago" --oneline | grep -oE "(BDA|FDA|SCA|ADA|IBA|QAA|DDA|DOA|PMA|CAA)" | sort | uniq -c)
        echo "agent_activity<<EOF" >> $GITHUB_OUTPUT
        echo "$AGENT_MENTIONS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: Sync Ticket Status Updates
      env:
        JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        cat << 'EOF' > sync_ticket_status.js
        const axios = require('axios');
        const core = require('@actions/core');
        
        const JIRA_BASE_URL = process.env.JIRA_BASE_URL;
        const JIRA_PROJECT_KEY = process.env.JIRA_PROJECT_KEY;
        const JIRA_EMAIL = process.env.JIRA_EMAIL;
        const JIRA_API_TOKEN = process.env.JIRA_API_TOKEN;
        
        const jiraAuth = {
          username: JIRA_EMAIL,
          password: JIRA_API_TOKEN
        };
        
        // GitHub event context
        const eventName = process.env.GITHUB_EVENT_NAME;
        const ref = process.env.GITHUB_REF;
        const sha = process.env.GITHUB_SHA;
        
        async function syncTicketStatus() {
          try {
            console.log(`Syncing tickets for event: ${eventName}`);
            
            // Get ticket references from commits or input
            const ticketRefs = process.env.TICKET_REFS ? 
              process.env.TICKET_REFS.split('\n').filter(ref => ref.trim()) : [];
            
            console.log(`Found ticket references: ${ticketRefs.join(', ')}`);
            
            // Process each ticket reference
            for (const ticketKey of ticketRefs) {
              if (!ticketKey.startsWith('AV11-')) continue;
              
              await updateTicketFromGitHub(ticketKey);
            }
            
            // Handle different GitHub events
            switch (eventName) {
              case 'push':
                await handlePushEvent();
                break;
              case 'pull_request':
                await handlePullRequestEvent();
                break;
              case 'issues':
                await handleIssueEvent();
                break;
            }
            
          } catch (error) {
            console.error('Error syncing ticket status:', error.message);
            if (error.response?.data) {
              console.error('JIRA API Error:', error.response.data);
            }
            throw error;
          }
        }
        
        async function updateTicketFromGitHub(ticketKey) {
          try {
            console.log(`Updating ${ticketKey} from GitHub activity`);
            
            // Get current ticket status
            const ticketResponse = await axios.get(
              `${JIRA_BASE_URL}/rest/api/3/issue/${ticketKey}`,
              {
                params: { fields: 'status,summary,assignee,labels' },
                auth: jiraAuth
              }
            );
            
            const ticket = ticketResponse.data;
            const currentStatus = ticket.fields.status.name;
            
            console.log(`${ticketKey}: Current status is ${currentStatus}`);
            
            // Determine new status based on GitHub activity
            let newStatus = null;
            let comment = '';
            
            if (eventName === 'push' && ref.includes('main')) {
              // Code merged to main - mark as completed if not already
              if (!['Done', 'Closed', 'Resolved'].includes(currentStatus)) {
                newStatus = 'Done';
                comment = `‚úÖ Code merged to main branch. Auto-updated from GitHub.\n\nCommit: ${sha.substring(0, 8)}`;
              }
            } else if (eventName === 'pull_request') {
              // PR opened - mark as in progress if still todo
              if (['To Do', 'Open', 'Backlog'].includes(currentStatus)) {
                newStatus = 'In Progress';
                comment = `üîÑ Pull request opened for this ticket. Auto-updated from GitHub.\n\nPR: #${process.env.PR_NUMBER || 'N/A'}`;
              }
            }
            
            // Update ticket status if needed
            if (newStatus && newStatus !== currentStatus) {
              await updateTicketStatus(ticketKey, newStatus);
            }
            
            // Add comment about GitHub activity
            if (comment) {
              await addTicketComment(ticketKey, comment);
            }
            
            // Update with GitHub link
            await updateTicketWithGitHubLink(ticketKey);
            
          } catch (error) {
            if (error.response?.status === 404) {
              console.log(`Ticket ${ticketKey} not found - may need to be created`);
              await createTicketFromGitHub(ticketKey);
            } else {
              console.error(`Error updating ${ticketKey}:`, error.message);
            }
          }
        }
        
        async function updateTicketStatus(ticketKey, newStatus) {
          try {
            // Get available transitions
            const transitionsResponse = await axios.get(
              `${JIRA_BASE_URL}/rest/api/3/issue/${ticketKey}/transitions`,
              { auth: jiraAuth }
            );
            
            const transitions = transitionsResponse.data.transitions;
            const transition = transitions.find(t => 
              t.name.toLowerCase().includes(newStatus.toLowerCase()) ||
              t.to.name.toLowerCase().includes(newStatus.toLowerCase())
            );
            
            if (transition) {
              await axios.post(
                `${JIRA_BASE_URL}/rest/api/3/issue/${ticketKey}/transitions`,
                {
                  transition: { id: transition.id }
                },
                { auth: jiraAuth }
              );
              
              console.log(`‚úÖ ${ticketKey} status updated to ${newStatus}`);
            } else {
              console.log(`‚ö†Ô∏è  No transition found for ${newStatus} on ${ticketKey}`);
            }
            
          } catch (error) {
            console.error(`Error transitioning ${ticketKey}:`, error.message);
          }
        }
        
        async function addTicketComment(ticketKey, comment) {
          try {
            await axios.post(
              `${JIRA_BASE_URL}/rest/api/3/issue/${ticketKey}/comment`,
              {
                body: {
                  type: "doc",
                  version: 1,
                  content: [
                    {
                      type: "paragraph",
                      content: [
                        {
                          type: "text",
                          text: comment
                        }
                      ]
                    }
                  ]
                }
              },
              { auth: jiraAuth }
            );
            
            console.log(`üí¨ Added comment to ${ticketKey}`);
            
          } catch (error) {
            console.error(`Error adding comment to ${ticketKey}:`, error.message);
          }
        }
        
        async function updateTicketWithGitHubLink(ticketKey) {
          try {
            const githubUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}`;
            const commitUrl = `${githubUrl}/commit/${sha}`;
            
            // Add web link to ticket
            await axios.post(
              `${JIRA_BASE_URL}/rest/api/3/issue/${ticketKey}/remotelink`,
              {
                globalId: `github-commit-${sha}`,
                application: {
                  type: "com.github.integration",
                  name: "GitHub"
                },
                relationship: "mentioned in",
                object: {
                  url: commitUrl,
                  title: `GitHub Commit ${sha.substring(0, 8)}`,
                  summary: "Referenced in commit",
                  icon: {
                    url16x16: "https://github.com/favicon.ico"
                  }
                }
              },
              { auth: jiraAuth }
            );
            
            console.log(`üîó Added GitHub link to ${ticketKey}`);
            
          } catch (error) {
            console.error(`Error adding GitHub link to ${ticketKey}:`, error.message);
          }
        }
        
        async function createTicketFromGitHub(ticketKey) {
          try {
            console.log(`Creating new ticket ${ticketKey} from GitHub activity`);
            
            // Extract ticket number for summary
            const ticketNumber = ticketKey.replace('AV11-', '');
            
            // Determine agent and sprint from commit context
            const commitMessage = process.env.COMMIT_MESSAGE || '';
            let assignedAgent = 'Unassigned';
            let sprintId = null;
            
            // Agent detection from commit message
            if (commitMessage.includes('BDA') || commitMessage.includes('backend')) assignedAgent = 'BDA';
            else if (commitMessage.includes('FDA') || commitMessage.includes('frontend')) assignedAgent = 'FDA';
            else if (commitMessage.includes('SCA') || commitMessage.includes('security')) assignedAgent = 'SCA';
            else if (commitMessage.includes('ADA') || commitMessage.includes('AI')) assignedAgent = 'ADA';
            else if (commitMessage.includes('IBA') || commitMessage.includes('bridge')) assignedAgent = 'IBA';
            else if (commitMessage.includes('QAA') || commitMessage.includes('test')) assignedAgent = 'QAA';
            else if (commitMessage.includes('DDA') || commitMessage.includes('deploy')) assignedAgent = 'DDA';
            else if (commitMessage.includes('DOA') || commitMessage.includes('doc')) assignedAgent = 'DOA';
            else if (commitMessage.includes('PMA') || commitMessage.includes('project')) assignedAgent = 'PMA';
            else if (commitMessage.includes('CAA') || commitMessage.includes('architect')) assignedAgent = 'CAA';
            
            const ticketData = {
              fields: {
                project: { key: JIRA_PROJECT_KEY },
                summary: `Auto-created: ${commitMessage.substring(0, 100)}`,
                description: {
                  type: "doc",
                  version: 1,
                  content: [
                    {
                      type: "paragraph",
                      content: [
                        {
                          type: "text",
                          text: `Ticket auto-created from GitHub activity.\n\nCommit: ${sha}\nMessage: ${commitMessage}\nAssigned Agent: ${assignedAgent}`
                        }
                      ]
                    }
                  ]
                },
                issuetype: { name: 'Task' },
                labels: ['auto-created', 'github-sync', assignedAgent.toLowerCase()]
              }
            };
            
            const response = await axios.post(
              `${JIRA_BASE_URL}/rest/api/3/issue`,
              ticketData,
              { auth: jiraAuth }
            );
            
            console.log(`‚úÖ Created ticket ${response.data.key}`);
            
          } catch (error) {
            console.error(`Error creating ticket ${ticketKey}:`, error.message);
            if (error.response?.data) {
              console.error('Create ticket error details:', error.response.data);
            }
          }
        }
        
        async function handlePushEvent() {
          console.log('Handling push event');
          
          // Additional push-specific logic
          const commitCount = parseInt(process.env.COMMIT_COUNT || '0');
          if (commitCount > 0) {
            console.log(`Processing ${commitCount} new commits`);
            
            // Update sprint velocity metrics
            await updateSprintVelocity(commitCount);
          }
        }
        
        async function handlePullRequestEvent() {
          console.log('Handling pull request event');
          
          const prAction = process.env.PR_ACTION;
          const prNumber = process.env.PR_NUMBER;
          
          if (prAction === 'closed' && process.env.PR_MERGED === 'true') {
            console.log(`PR #${prNumber} merged - updating related tickets`);
            // Additional logic for merged PRs
          }
        }
        
        async function handleIssueEvent() {
          console.log('Handling GitHub issue event');
          
          const issueAction = process.env.ISSUE_ACTION;
          const issueNumber = process.env.ISSUE_NUMBER;
          
          // Create corresponding JIRA ticket for GitHub issues
          if (issueAction === 'opened') {
            await createJiraFromGitHubIssue(issueNumber);
          }
        }
        
        async function updateSprintVelocity(commitCount) {
          try {
            // Update sprint metrics with commit velocity
            console.log(`Updating sprint velocity with ${commitCount} commits`);
            
            // This could update custom fields or add comments to sprint tracking tickets
            const sprintVelocityData = {
              timestamp: new Date().toISOString(),
              commits: commitCount,
              repository: process.env.GITHUB_REPOSITORY,
              ref: process.env.GITHUB_REF
            };
            
            console.log('Sprint velocity data recorded:', sprintVelocityData);
            
          } catch (error) {
            console.error('Error updating sprint velocity:', error.message);
          }
        }
        
        async function createJiraFromGitHubIssue(issueNumber) {
          try {
            console.log(`Creating JIRA ticket from GitHub issue #${issueNumber}`);
            
            // Implementation would fetch GitHub issue details and create JIRA ticket
            // This is a placeholder for the full implementation
            
          } catch (error) {
            console.error(`Error creating JIRA from GitHub issue #${issueNumber}:`, error.message);
          }
        }
        
        // Run the synchronization
        syncTicketStatus()
          .then(() => {
            console.log('‚úÖ Ticket synchronization completed successfully');
            process.exit(0);
          })
          .catch(error => {
            console.error('‚ùå Ticket synchronization failed:', error.message);
            process.exit(1);
          });
        EOF
        
        # Set environment variables for the script
        export TICKET_REFS="${{ steps.commit-info.outputs.ticket_refs }}"
        export COMMIT_COUNT="${{ steps.commit-info.outputs.commit_count }}"
        export COMMIT_MESSAGE="${{ github.event.head_commit.message }}"
        export PR_NUMBER="${{ github.event.pull_request.number }}"
        export PR_ACTION="${{ github.event.action }}"
        export PR_MERGED="${{ github.event.pull_request.merged }}"
        export ISSUE_NUMBER="${{ github.event.issue.number }}"
        export ISSUE_ACTION="${{ github.event.action }}"
        
        node sync_ticket_status.js
        
    - name: Create Missing Tickets
      env:
        JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
      run: |
        cat << 'EOF' > create_missing_tickets.js
        const axios = require('axios');
        
        const JIRA_BASE_URL = process.env.JIRA_BASE_URL;
        const JIRA_PROJECT_KEY = process.env.JIRA_PROJECT_KEY;
        const JIRA_EMAIL = process.env.JIRA_EMAIL;
        const JIRA_API_TOKEN = process.env.JIRA_API_TOKEN;
        
        const jiraAuth = {
          username: JIRA_EMAIL,
          password: JIRA_API_TOKEN
        };
        
        // Comprehensive ticket definitions for all 6 sprints
        const ALL_SPRINT_TICKETS = {
          // Sprint 1: Core Model Classes (Completed)
          'AV11-1': { sprint: 1, title: 'Core Model Classes - Foundation Architecture', agent: 'CAA', status: 'Done' },
          'AV11-2': { sprint: 1, title: 'Transaction Models and Data Structures', agent: 'BDA', status: 'Done' },
          'AV11-3': { sprint: 1, title: 'Consensus Models and Voting Mechanisms', agent: 'BDA', status: 'Done' },
          'AV11-4': { sprint: 1, title: 'Crypto Models and Security Primitives', agent: 'SCA', status: 'Done' },
          'AV11-5': { sprint: 1, title: 'Network Models and Communication Protocols', agent: 'IBA', status: 'Done' },
          
          // Sprint 2: Contract & Bridge Services (Completed)
          'AV11-6': { sprint: 2, title: 'Smart Contract Service Implementation', agent: 'BDA', status: 'Done' },
          'AV11-7': { sprint: 2, title: 'Cross-Chain Bridge Service', agent: 'IBA', status: 'Done' },
          'AV11-8': { sprint: 2, title: 'Contract Execution Engine', agent: 'BDA', status: 'Done' },
          'AV11-9': { sprint: 2, title: 'Bridge Protocol Adapters', agent: 'IBA', status: 'Done' },
          'AV11-10': { sprint: 2, title: 'Contract Security Validation', agent: 'SCA', status: 'Done' },
          
          // Sprint 3: API Resources & Integration (Completed)
          'AV11-11': { sprint: 3, title: 'REST API Resource Implementation', agent: 'BDA', status: 'Done' },
          'AV11-12': { sprint: 3, title: 'gRPC Service Integration', agent: 'BDA', status: 'Done' },
          'AV11-13': { sprint: 3, title: 'API Gateway and Load Balancing', agent: 'DDA', status: 'Done' },
          'AV11-14': { sprint: 3, title: 'External Service Integrations', agent: 'IBA', status: 'Done' },
          'AV11-15': { sprint: 3, title: 'API Documentation and Testing', agent: 'DOA', status: 'Done' },
          
          // Sprint 4: Testing & Security (Completed)  
          'AV11-16': { sprint: 4, title: 'Comprehensive Test Suite Implementation', agent: 'QAA', status: 'Done' },
          'AV11-17': { sprint: 4, title: 'Security Audit and Penetration Testing', agent: 'SCA', status: 'Done' },
          'AV11-18': { sprint: 4, title: 'Performance Testing Framework', agent: 'QAA', status: 'Done' },
          'AV11-19': { sprint: 4, title: 'Quantum Cryptography Integration', agent: 'SCA', status: 'Done' },
          'AV11-20': { sprint: 4, title: 'Automated Testing Pipeline', agent: 'DDA', status: 'Done' },
          
          // Sprint 5: Performance & Deployment (In Progress)
          'AV11-21': { sprint: 5, title: 'Performance Optimization (2M+ TPS)', agent: 'ADA', status: 'In Progress' },
          'AV11-22': { sprint: 5, title: 'Native Compilation Optimization', agent: 'DDA', status: 'In Progress' },
          'AV11-23': { sprint: 5, title: 'Production Deployment Infrastructure', agent: 'DDA', status: 'In Progress' },
          'AV11-24': { sprint: 5, title: 'HMS Healthcare Integration', agent: 'IBA', status: 'In Progress' },
          'AV11-25': { sprint: 5, title: 'Advanced Monitoring and Metrics', agent: 'DDA', status: 'In Progress' },
          
          // Sprint 6: Ricardian Smart Contract Framework (Pending)
          'AV11-26': { sprint: 6, title: 'Ricardian Contract Framework Core', agent: 'BDA', status: 'To Do' },
          'AV11-27': { sprint: 6, title: 'Legal Compliance Automation', agent: 'SCA', status: 'To Do' },
          'AV11-28': { sprint: 6, title: 'Multi-Party Signature Workflows', agent: 'BDA', status: 'To Do' },
          'AV11-29': { sprint: 6, title: 'Contract Template Registry', agent: 'BDA', status: 'To Do' },
          'AV11-30': { sprint: 6, title: 'Advanced Contract Verification', agent: 'SCA', status: 'To Do' }
        };
        
        async function createMissingTickets() {
          try {
            console.log('Checking for missing tickets across all 6 sprints...');
            
            // Get existing tickets
            const existingResponse = await axios.get(
              `${JIRA_BASE_URL}/rest/api/3/search`,
              {
                params: {
                  jql: `project = ${JIRA_PROJECT_KEY} ORDER BY key ASC`,
                  fields: 'key,summary,status',
                  maxResults: 1000
                },
                auth: jiraAuth
              }
            );
            
            const existingTickets = existingResponse.data.issues.map(issue => issue.key);
            console.log(`Found ${existingTickets.length} existing tickets`);
            
            // Create missing tickets
            let createdCount = 0;
            for (const [ticketKey, ticketInfo] of Object.entries(ALL_SPRINT_TICKETS)) {
              if (!existingTickets.includes(ticketKey)) {
                await createTicket(ticketKey, ticketInfo);
                createdCount++;
              } else {
                console.log(`‚úì ${ticketKey} already exists`);
              }
            }
            
            console.log(`‚úÖ Created ${createdCount} missing tickets`);
            
          } catch (error) {
            console.error('Error creating missing tickets:', error.message);
            if (error.response?.data) {
              console.error('API Error Details:', error.response.data);
            }
          }
        }
        
        async function createTicket(ticketKey, ticketInfo) {
          try {
            const ticketData = {
              fields: {
                project: { key: JIRA_PROJECT_KEY },
                summary: `${ticketInfo.title}`,
                description: {
                  type: "doc",
                  version: 1,
                  content: [
                    {
                      type: "paragraph",
                      content: [
                        {
                          type: "text",
                          text: `Sprint ${ticketInfo.sprint} - ${ticketInfo.title}\n\nAssigned Agent: ${ticketInfo.agent}\nAuto-created by GitHub Actions\n\nThis ticket is part of the Aurigraph V11 migration project.`
                        }
                      ]
                    }
                  ]
                },
                issuetype: { name: 'Task' },
                labels: [
                  `sprint-${ticketInfo.sprint}`,
                  ticketInfo.agent.toLowerCase(),
                  'aurigraph-v11',
                  'auto-created'
                ]
              }
            };
            
            const response = await axios.post(
              `${JIRA_BASE_URL}/rest/api/3/issue`,
              ticketData,
              { auth: jiraAuth }
            );
            
            console.log(`‚úÖ Created ${response.data.key}: ${ticketInfo.title}`);
            
            // Set initial status if not default
            if (ticketInfo.status !== 'To Do') {
              await updateTicketStatus(response.data.key, ticketInfo.status);
            }
            
          } catch (error) {
            console.error(`Error creating ${ticketKey}:`, error.message);
            if (error.response?.data?.errors) {
              console.error('Field errors:', error.response.data.errors);
            }
          }
        }
        
        async function updateTicketStatus(ticketKey, targetStatus) {
          try {
            // Get available transitions
            const transitionsResponse = await axios.get(
              `${JIRA_BASE_URL}/rest/api/3/issue/${ticketKey}/transitions`,
              { auth: jiraAuth }
            );
            
            const transitions = transitionsResponse.data.transitions;
            const transition = transitions.find(t => 
              t.name.toLowerCase().includes(targetStatus.toLowerCase()) ||
              t.to.name.toLowerCase().includes(targetStatus.toLowerCase())
            );
            
            if (transition) {
              await axios.post(
                `${JIRA_BASE_URL}/rest/api/3/issue/${ticketKey}/transitions`,
                { transition: { id: transition.id } },
                { auth: jiraAuth }
              );
              
              console.log(`  ‚îî‚îÄ Status updated to ${targetStatus}`);
            }
            
          } catch (error) {
            console.error(`  ‚îî‚îÄ Could not update status for ${ticketKey}:`, error.message);
          }
        }
        
        createMissingTickets();
        EOF
        
        node create_missing_tickets.js
        
    - name: Update Agent Assignment
      env:
        JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
      run: |
        cat << 'EOF' > update_agent_assignments.js
        const axios = require('axios');
        
        const JIRA_BASE_URL = process.env.JIRA_BASE_URL;
        const JIRA_PROJECT_KEY = process.env.JIRA_PROJECT_KEY;
        const JIRA_EMAIL = process.env.JIRA_EMAIL;
        const JIRA_API_TOKEN = process.env.JIRA_API_TOKEN;
        
        const jiraAuth = {
          username: JIRA_EMAIL,
          password: JIRA_API_TOKEN
        };
        
        // Agent assignments based on recent activity
        const agentActivity = process.env.AGENT_ACTIVITY || '';
        
        async function updateAgentAssignments() {
          try {
            console.log('Updating agent assignments based on recent activity...');
            
            if (agentActivity) {
              console.log('Recent agent activity:');
              console.log(agentActivity);
              
              // Parse agent mentions and update ticket assignments accordingly
              const agentMentions = agentActivity.split('\n').filter(line => line.trim());
              
              for (const mention of agentMentions) {
                const [count, agent] = mention.trim().split(/\s+/);
                if (agent && ['BDA', 'FDA', 'SCA', 'ADA', 'IBA', 'QAA', 'DDA', 'DOA', 'PMA', 'CAA'].includes(agent)) {
                  console.log(`${agent}: ${count} recent activities`);
                  
                  // Update tickets assigned to this agent
                  await updateTicketsForAgent(agent, parseInt(count));
                }
              }
            }
            
          } catch (error) {
            console.error('Error updating agent assignments:', error.message);
          }
        }
        
        async function updateTicketsForAgent(agent, activityCount) {
          try {
            // Find tickets for this agent
            const searchResponse = await axios.get(
              `${JIRA_BASE_URL}/rest/api/3/search`,
              {
                params: {
                  jql: `project = ${JIRA_PROJECT_KEY} AND labels = ${agent.toLowerCase()}`,
                  fields: 'key,summary,status',
                  maxResults: 50
                },
                auth: jiraAuth
              }
            );
            
            const tickets = searchResponse.data.issues;
            console.log(`Found ${tickets.length} tickets for ${agent}`);
            
            // Add activity comment to active tickets
            for (const ticket of tickets) {
              if (!['Done', 'Closed', 'Resolved'].includes(ticket.fields.status.name)) {
                await addActivityComment(ticket.key, agent, activityCount);
              }
            }
            
          } catch (error) {
            console.error(`Error updating tickets for ${agent}:`, error.message);
          }
        }
        
        async function addActivityComment(ticketKey, agent, activityCount) {
          try {
            const timestamp = new Date().toISOString();
            const comment = `ü§ñ Agent ${agent} activity detected: ${activityCount} recent commits/changes\n\nAuto-updated: ${timestamp}`;
            
            await axios.post(
              `${JIRA_BASE_URL}/rest/api/3/issue/${ticketKey}/comment`,
              {
                body: {
                  type: "doc",
                  version: 1,
                  content: [
                    {
                      type: "paragraph", 
                      content: [
                        {
                          type: "text",
                          text: comment
                        }
                      ]
                    }
                  ]
                }
              },
              { auth: jiraAuth }
            );
            
            console.log(`  ‚îî‚îÄ Added activity comment to ${ticketKey}`);
            
          } catch (error) {
            console.error(`  ‚îî‚îÄ Error adding comment to ${ticketKey}:`, error.message);
          }
        }
        
        updateAgentAssignments();
        EOF
        
        export AGENT_ACTIVITY="${{ steps.commit-info.outputs.agent_activity }}"
        node update_agent_assignments.js
        
    - name: Generate Sync Report
      run: |
        cat << 'EOF' > sync_report.md
        # JIRA Ticket Synchronization Report
        
        **Generated:** $(date)
        **Event:** ${{ github.event_name }}
        **Repository:** ${{ github.repository }}
        **Branch:** ${{ github.ref }}
        
        ## Synchronization Summary
        
        ### Commit Analysis
        - **Recent Commits:** ${{ steps.commit-info.outputs.commit_count }}
        - **Ticket References Found:** 
        ```
        ${{ steps.commit-info.outputs.ticket_refs }}
        ```
        
        ### Agent Activity
        ```
        ${{ steps.commit-info.outputs.agent_activity }}
        ```
        
        ### Actions Performed
        - ‚úÖ Ticket status synchronization
        - ‚úÖ Missing ticket creation
        - ‚úÖ Agent assignment updates
        - ‚úÖ GitHub link integration
        - ‚úÖ Automated comments added
        
        ### Next Steps
        1. Review auto-updated ticket statuses
        2. Verify agent assignments
        3. Check GitHub integration links
        4. Monitor sprint progress impact
        
        ---
        
        *This report is automatically generated by the JIRA Ticket Sync system.*
        *Last sync: $(date)*
        EOF
        
        # Save the report
        mkdir -p sync-reports
        cp sync_report.md sync-reports/sync-report-$(date +%Y%m%d-%H%M%S).md
        
    - name: Upload Sync Report
      uses: actions/upload-artifact@v4
      with:
        name: jira-sync-report-${{ github.run_number }}
        path: |
          sync-reports/
          *.log
        retention-days: 30
        
    - name: Notify on Failure
      if: failure()
      uses: actions/github-script@v7
      with:
        script: |
          const title = 'üö® JIRA Ticket Sync Failed';
          const body = `
          ## JIRA Synchronization Failure
          
          **Repository:** \`${{ github.repository }}\`
          **Workflow:** \`${{ github.workflow }}\`
          **Run ID:** \`${{ github.run_id }}\`
          **Event:** \`${{ github.event_name }}\`
          
          ### Failure Details
          - **Branch:** \`${{ github.ref }}\`
          - **Commit:** \`${{ github.sha }}\`
          - **Time:** ${new Date().toISOString()}
          
          ### Recommended Actions
          1. Check JIRA API token validity
          2. Verify JIRA project permissions
          3. Review workflow logs for specific errors
          4. Manually sync critical tickets if needed
          
          **View Logs:** [Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          
          ---
          *Auto-generated failure notification*
          `;
          
          // This would create an issue or notification
          console.log('JIRA Sync Failure Notification:');
          console.log(title);
          console.log(body);