name: CD - Deploy to Environments

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip smoke tests'
        required: false
        type: boolean
        default: false

  push:
    branches:
      - main
    paths:
      - 'aurigraph-av10-7/aurigraph-v11-standalone/**'
      - '.github/workflows/deploy.yml'

  release:
    types: [published]

env:
  JAVA_VERSION: '21'
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: aurigraph-dlt/aurigraph-v11
  STAGING_URL: https://staging.dlt.aurigraph.io
  PRODUCTION_URL: https://dlt.aurigraph.io

jobs:
  # Job 1: Pre-deployment Validation
  pre-deployment-validation:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 15

    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      version: ${{ steps.version.outputs.version }}
      should_deploy: ${{ steps.validation.outputs.should_deploy }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Determine Target Environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "release" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Extract Version
        id: version
        run: |
          VERSION=$(grep -oP '(?<=<version>)[^<]+' aurigraph-av10-7/aurigraph-v11-standalone/pom.xml | head -1)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION"

      - name: Validate Deployment
        id: validation
        run: |
          ENV="${{ steps.determine-env.outputs.environment }}"

          # Production requires tag or release
          if [[ "$ENV" == "production" ]] && [[ "${{ github.event_name }}" != "release" ]] && [[ "${{ github.event_name }}" != "workflow_dispatch" ]]; then
            echo "‚ùå Production deployments require a release or manual trigger"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Validate branch for staging
          if [[ "$ENV" == "staging" ]] && [[ "${{ github.ref }}" != "refs/heads/main" ]] && [[ "${{ github.event_name }}" != "workflow_dispatch" ]]; then
            echo "‚ùå Staging deployments only allowed from main branch"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "‚úÖ Deployment validation passed"
          echo "should_deploy=true" >> $GITHUB_OUTPUT

      - name: Summary
        run: |
          echo "# üöÄ Deployment Plan" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ steps.determine-env.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

  # Job 2: Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: pre-deployment-validation
    if: needs.pre-deployment-validation.outputs.environment == 'staging' && needs.pre-deployment-validation.outputs.should_deploy == 'true'
    environment:
      name: staging
      url: ${{ env.STAGING_URL }}
    timeout-minutes: 20

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull Latest Docker Image
        run: |
          IMAGE_TAG="${{ github.ref_name }}-${{ github.sha }}"
          docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG || \
          docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Deploy to Staging (Docker Compose)
        run: |
          echo "üöÄ Deploying to staging environment..."

          # SSH to staging server and deploy
          ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }} << 'EOF'
            cd /opt/aurigraph/staging

            # Pull latest code
            git pull origin main

            # Update environment variables
            export IMAGE_TAG="${{ github.ref_name }}-${{ github.sha }}"
            export VERSION="${{ needs.pre-deployment-validation.outputs.version }}"

            # Deploy with docker-compose
            docker-compose -f docker-compose.staging.yml pull
            docker-compose -f docker-compose.staging.yml up -d --no-deps aurigraph-v11

            echo "‚úÖ Deployment completed"
          EOF

      - name: Wait for Service to Start
        run: |
          echo "‚è≥ Waiting for service to become healthy..."

          MAX_ATTEMPTS=30
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            if curl -f -s ${{ env.STAGING_URL }}/q/health > /dev/null; then
              echo "‚úÖ Service is healthy"
              exit 0
            fi

            ATTEMPT=$((ATTEMPT+1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS - Service not ready yet..."
            sleep 10
          done

          echo "‚ùå Service health check failed after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Run Smoke Tests
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "üß™ Running smoke tests..."

          # Test health endpoint
          curl -f -s ${{ env.STAGING_URL }}/q/health | jq '.'

          # Test info endpoint
          curl -f -s ${{ env.STAGING_URL }}/api/v11/info | jq '.'

          # Test metrics endpoint
          curl -f -s ${{ env.STAGING_URL }}/q/metrics | grep -q "jvm_memory_used_bytes"

          echo "‚úÖ Smoke tests passed"

      - name: Deployment Summary
        run: |
          echo "# ‚úÖ Staging Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Staging" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.pre-deployment-validation.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed at**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  # Job 3: Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-deployment-validation
    if: needs.pre-deployment-validation.outputs.environment == 'production' && needs.pre-deployment-validation.outputs.should_deploy == 'true'
    environment:
      name: production
      url: ${{ env.PRODUCTION_URL }}
    timeout-minutes: 30

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Backup of Current Production
        run: |
          echo "üíæ Creating backup of current production deployment..."

          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_SSH_USER }}@${{ secrets.PRODUCTION_SSH_HOST }} << 'EOF'
            cd /opt/aurigraph/production

            # Backup current configuration
            BACKUP_DIR="/opt/aurigraph/backups/$(date +%Y%m%d_%H%M%S)"
            mkdir -p $BACKUP_DIR

            # Save current docker-compose.yml and .env
            cp docker-compose.production.yml $BACKUP_DIR/
            cp .env $BACKUP_DIR/

            # Save current container info
            docker-compose -f docker-compose.production.yml ps > $BACKUP_DIR/container_status.txt

            echo "‚úÖ Backup created at $BACKUP_DIR"
          EOF

      - name: Deploy to Production (Blue-Green Strategy)
        run: |
          echo "üöÄ Deploying to production environment (blue-green deployment)..."

          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_SSH_USER }}@${{ secrets.PRODUCTION_SSH_HOST }} << 'EOF'
            cd /opt/aurigraph/production

            # Pull latest code
            git pull origin main

            # Update environment variables
            export IMAGE_TAG="${{ github.sha }}"
            export VERSION="${{ needs.pre-deployment-validation.outputs.version }}"

            # Deploy new version as "green" instance
            docker-compose -f docker-compose.production.yml pull aurigraph-v11-green
            docker-compose -f docker-compose.production.yml up -d aurigraph-v11-green

            # Wait for green instance to be healthy
            echo "‚è≥ Waiting for green instance to become healthy..."
            sleep 30

            # Check green instance health
            if curl -f -s http://localhost:9004/q/health > /dev/null; then
              echo "‚úÖ Green instance is healthy"

              # Switch traffic to green (update load balancer)
              ./scripts/switch-to-green.sh

              # Stop blue instance
              docker-compose -f docker-compose.production.yml stop aurigraph-v11-blue

              # Rename green to blue for next deployment
              docker-compose -f docker-compose.production.yml stop aurigraph-v11-green
              docker-compose -f docker-compose.production.yml rm -f aurigraph-v11-green
              docker-compose -f docker-compose.production.yml up -d aurigraph-v11-blue

              echo "‚úÖ Blue-green deployment completed"
            else
              echo "‚ùå Green instance health check failed - rolling back"
              docker-compose -f docker-compose.production.yml stop aurigraph-v11-green
              exit 1
            fi
          EOF

      - name: Wait for Production Service
        run: |
          echo "‚è≥ Waiting for production service to become healthy..."

          MAX_ATTEMPTS=60
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            if curl -f -s ${{ env.PRODUCTION_URL }}/q/health > /dev/null; then
              echo "‚úÖ Production service is healthy"
              exit 0
            fi

            ATTEMPT=$((ATTEMPT+1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS - Service not ready yet..."
            sleep 10
          done

          echo "‚ùå Production service health check failed after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Run Production Smoke Tests
        if: ${{ !inputs.skip_tests }}
        run: |
          echo "üß™ Running production smoke tests..."

          # Test health endpoint
          curl -f -s ${{ env.PRODUCTION_URL }}/q/health | jq '.'

          # Test info endpoint
          curl -f -s ${{ env.PRODUCTION_URL }}/api/v11/info | jq '.'

          # Test metrics endpoint
          curl -f -s ${{ env.PRODUCTION_URL }}/q/metrics | grep -q "jvm_memory_used_bytes"

          # Test transaction endpoint (read-only)
          curl -f -s "${{ env.PRODUCTION_URL }}/api/v11/blockchain/transactions?limit=10" | jq '.'

          echo "‚úÖ Production smoke tests passed"

      - name: Monitor for 5 Minutes
        run: |
          echo "üìä Monitoring production for 5 minutes..."

          for i in {1..30}; do
            if ! curl -f -s ${{ env.PRODUCTION_URL }}/q/health > /dev/null; then
              echo "‚ùå Health check failed during monitoring period"
              exit 1
            fi
            echo "‚úÖ Health check $i/30 passed"
            sleep 10
          done

          echo "‚úÖ Production monitoring completed successfully"

      - name: Deployment Summary
        run: |
          echo "# üéâ Production Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Production" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: ${{ env.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.pre-deployment-validation.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed at**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "- **Strategy**: Blue-Green Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üîç Post-Deployment Actions" >> $GITHUB_STEP_SUMMARY
          echo "1. Monitor application logs" >> $GITHUB_STEP_SUMMARY
          echo "2. Check Grafana dashboards" >> $GITHUB_STEP_SUMMARY
          echo "3. Verify transaction processing" >> $GITHUB_STEP_SUMMARY
          echo "4. Monitor error rates" >> $GITHUB_STEP_SUMMARY

  # Job 4: Rollback Capability
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
    needs: [pre-deployment-validation, deploy-staging, deploy-production]
    environment:
      name: ${{ needs.pre-deployment-validation.outputs.environment }}
    timeout-minutes: 15

    steps:
      - name: Determine Rollback Environment
        id: env
        run: |
          if [[ "${{ needs.deploy-production.result }}" == "failure" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "ssh_user=${{ secrets.PRODUCTION_SSH_USER }}" >> $GITHUB_OUTPUT
            echo "ssh_host=${{ secrets.PRODUCTION_SSH_HOST }}" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "ssh_user=${{ secrets.STAGING_SSH_USER }}" >> $GITHUB_OUTPUT
            echo "ssh_host=${{ secrets.STAGING_SSH_HOST }}" >> $GITHUB_OUTPUT
          fi

      - name: Execute Rollback
        run: |
          echo "üîÑ Executing rollback for ${{ steps.env.outputs.environment }}..."

          ssh -o StrictHostKeyChecking=no ${{ steps.env.outputs.ssh_user }}@${{ steps.env.outputs.ssh_host }} << 'EOF'
            cd /opt/aurigraph/${{ steps.env.outputs.environment }}

            # Find latest backup
            LATEST_BACKUP=$(ls -t /opt/aurigraph/backups/ | head -1)

            if [ -z "$LATEST_BACKUP" ]; then
              echo "‚ùå No backup found for rollback"
              exit 1
            fi

            echo "üì¶ Rolling back to backup: $LATEST_BACKUP"

            # Restore configuration
            cp /opt/aurigraph/backups/$LATEST_BACKUP/docker-compose.*.yml ./
            cp /opt/aurigraph/backups/$LATEST_BACKUP/.env ./

            # Restart with previous configuration
            docker-compose -f docker-compose.${{ steps.env.outputs.environment }}.yml down
            docker-compose -f docker-compose.${{ steps.env.outputs.environment }}.yml up -d

            echo "‚úÖ Rollback completed"
          EOF

      - name: Verify Rollback
        run: |
          echo "üîç Verifying rollback..."

          URL="${{ steps.env.outputs.environment == 'production' && env.PRODUCTION_URL || env.STAGING_URL }}"

          MAX_ATTEMPTS=30
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            if curl -f -s $URL/q/health > /dev/null; then
              echo "‚úÖ Service is healthy after rollback"
              exit 0
            fi

            ATTEMPT=$((ATTEMPT+1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS - Service not ready yet..."
            sleep 10
          done

          echo "‚ùå Service health check failed after rollback"
          exit 1

      - name: Rollback Summary
        run: |
          echo "# ‚ö†Ô∏è Rollback Executed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ steps.env.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Reason**: Deployment failure" >> $GITHUB_STEP_SUMMARY
          echo "- **Rolled back at**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üîç Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review deployment logs" >> $GITHUB_STEP_SUMMARY
          echo "2. Identify root cause of failure" >> $GITHUB_STEP_SUMMARY
          echo "3. Fix issues and redeploy" >> $GITHUB_STEP_SUMMARY

      - name: Notify Team
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: custom
          custom_payload: |
            {
              text: "üîÑ Rollback executed for ${{ steps.env.outputs.environment }} environment",
              attachments: [{
                color: 'danger',
                text: `Deployment to ${{ steps.env.outputs.environment }} failed and was rolled back.\nCommit: ${{ github.sha }}\nAuthor: ${{ github.actor }}`
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Job 5: Post-Deployment Notifications
  notify:
    name: Deployment Notifications
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()

    steps:
      - name: Slack Notification - Success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: '‚úÖ Deployment successful'
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Slack Notification - Failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: '‚ùå Deployment failed'
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
