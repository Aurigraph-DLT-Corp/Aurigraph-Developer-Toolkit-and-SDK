# =============================================================================
# JVM OPTIMIZATION CONFIGURATION - SPRINT 15
# Performance Target: 3.0M → 3.5M+ TPS
# Date: November 4, 2025
# Agent: BDA-Performance (Performance Optimization Agent)
# =============================================================================

# =============================================================================
# 1. GARBAGE COLLECTION (G1GC) OPTIMIZATION
# =============================================================================

# Use G1 Garbage Collector (optimized for low-latency, high-throughput)
-XX:+UseG1GC

# Target maximum GC pause time (100ms for 3.5M+ TPS)
# Current: ~50ms average, Target: <100ms maximum
-XX:MaxGCPauseMillis=100

# Enable parallel reference processing (reduces GC pause time)
# Expected improvement: -10ms GC pause
-XX:+ParallelRefProcEnabled

# Experimental G1GC tuning for throughput
-XX:+UnlockExperimentalVMOptions

# New generation collection percentage (30% of total GC time)
# Optimizes young generation sizing for 3.5M TPS workload
-XX:G1NewCollectionSetPercentage=30

# Maximum new generation percentage (40% of heap)
# Balances young/old gen for high transaction throughput
-XX:G1MaxNewGenPercent=40

# G1 region size (8MB for 2-4GB heap)
# Optimizes region management for transaction batching
-XX:G1HeapRegionSize=8m

# Initiating heap occupancy percent for concurrent marking (45%)
# Starts concurrent GC earlier to prevent full GC
-XX:InitiatingHeapOccupancyPercent=45

# G1 mixed GC live threshold (85%)
# Only collect regions with <15% live objects
-XX:G1MixedGCLiveThresholdPercent=85

# G1 old collection set candidate chunk size (10%)
# Limits old gen collection per mixed GC cycle
-XX:G1OldCSetRegionThresholdPercent=10

# Enable adaptive size policy (auto-tune heap sizes)
-XX:+UseAdaptiveSizePolicy

# =============================================================================
# 2. HEAP MEMORY CONFIGURATION
# =============================================================================

# Initial heap size (2GB for consistent startup performance)
# Prevents heap resizing during warmup
-Xms2g

# Maximum heap size (2GB to meet Sprint 15 target)
# Current: 2.5GB → Target: 2GB
-Xmx2g

# Young generation size (800MB, 40% of 2GB heap)
# Optimized for high transaction allocation rate
-XX:NewSize=800m
-XX:MaxNewSize=800m

# Survivor space ratio (6 = 1/7 of young gen)
# Balances promotion rate to old generation
-XX:SurvivorRatio=6

# Target survivor ratio (90%)
# Keeps objects in young gen longer
-XX:TargetSurvivorRatio=90

# Tenuring threshold (10 young gen cycles before promotion)
# Prevents premature promotion to old gen
-XX:MaxTenuringThreshold=10

# Direct memory size (512MB for off-heap buffers)
# Used by gRPC and network communication
-XX:MaxDirectMemorySize=512m

# Metaspace configuration (256MB initial, 512MB max)
# For class metadata (Quarkus + dependencies)
-XX:MetaspaceSize=256m
-XX:MaxMetaspaceSize=512m

# =============================================================================
# 3. PERFORMANCE OPTIMIZATION FLAGS
# =============================================================================

# Enable tiered compilation (C1 + C2 JIT compilers)
# Faster startup with eventual peak performance
-XX:+TieredCompilation

# Tier threshold for C2 compilation (aggressive optimization)
# Compile hot methods faster to C2 optimized code
-XX:Tier3InvocationThreshold=1000
-XX:Tier4InvocationThreshold=5000

# Code cache size (256MB for JIT compiled code)
# Ensures all hot paths are compiled
-XX:ReservedCodeCacheSize=256m
-XX:InitialCodeCacheSize=128m

# Inline method size limits (increase for better inlining)
-XX:MaxInlineSize=128
-XX:FreqInlineSize=512

# Enable aggressive opts (experimental optimizations)
-XX:+AggressiveOpts

# Compiler thread count (4 threads for compilation)
# Balances compilation speed vs. CPU usage
-XX:CICompilerCount=4

# Optimize string concatenation (StringBuilder optimization)
-XX:+OptimizeStringConcat

# Enable intrinsics for common operations
-XX:+UseFastAccessorMethods
-XX:+UseFastEmptyMethods

# Escape analysis (eliminates allocations for local objects)
-XX:+DoEscapeAnalysis

# Eliminate locks for non-contended synchronized blocks
-XX:+EliminateLocks

# Biased locking (reduces locking overhead)
-XX:+UseBiasedLocking
-XX:BiasedLockingStartupDelay=0

# =============================================================================
# 4. VIRTUAL THREADS CONFIGURATION (Java 21)
# =============================================================================

# Limit virtual thread scheduler parallelism (32 threads)
# Sprint 11 optimization: Reduced from 2,137 to 32 for optimal CPU
# Source: TODO.md lines 477-492, application.properties lines 487-492
-Djdk.virtualThreadScheduler.parallelism=32
-Djdk.virtualThreadScheduler.maxPoolSize=32

# Virtual thread carrier thread park timeout (100ms)
-Djdk.virtualThreadScheduler.parkTimeout=100

# Virtual thread continuation pinning detection
-Djdk.tracePinnedThreads=short

# =============================================================================
# 5. THREAD CONFIGURATION
# =============================================================================

# Platform thread stack size (512KB per thread)
# Smaller stack for more threads (default: 1MB)
-Xss512k

# Native memory tracking (for debugging, disable in production)
# Uncomment for memory leak investigation
# -XX:NativeMemoryTracking=summary

# Large page support (if available, improves TLB performance)
# Requires OS configuration: sudo sysctl -w vm.nr_hugepages=512
-XX:+UseLargePages

# Transparent huge pages (automatic huge page allocation)
-XX:+UseTransparentHugePages

# =============================================================================
# 6. NETWORK OPTIMIZATION
# =============================================================================

# Prefer IPv4 stack (reduces DNS lookup overhead)
-Djava.net.preferIPv4Stack=true

# Faster random number generation for TLS (non-blocking)
-Djava.security.egd=file:/dev/urandom

# Enable native memory tracking for network buffers
-Dio.netty.allocator.type=pooled

# Netty direct buffer pool (reduces GC for network I/O)
-Dio.netty.allocator.useCacheForAllThreads=true
-Dio.netty.maxDirectMemory=512m

# Disable Netty leak detection in production (performance overhead)
-Dio.netty.leakDetection.level=disabled

# =============================================================================
# 7. LOGGING & MONITORING
# =============================================================================

# GC logging (for performance analysis)
-Xlog:gc*:file=/var/log/aurigraph/gc.log:time,level,tags:filecount=5,filesize=100m

# JIT compilation logging (for optimization verification)
-XX:+PrintCompilation
-XX:+UnlockDiagnosticVMOptions
-XX:+LogCompilation
-XX:LogFile=/var/log/aurigraph/compilation.log

# Class loading statistics (for debugging startup performance)
# Uncomment for analysis
# -XX:+TraceClassLoading
# -XX:+TraceClassUnloading

# =============================================================================
# 8. QUARKUS-SPECIFIC OPTIMIZATIONS
# =============================================================================

# Quarkus native image optimization level (3 = maximum)
-Dquarkus.native.optimization-level=3

# CPU architecture-specific optimizations (x86-64-v3)
-Dquarkus.native.additional-build-args=-march=native

# Enable profile-guided optimization (PGO) if available
-Dquarkus.native.pgo.enabled=true

# Reduce startup time (skip unnecessary initialization)
-Dquarkus.native.enable-isolates=true

# =============================================================================
# 9. PERFORMANCE MONITORING FLAGS
# =============================================================================

# Enable JMX monitoring
-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=9010
-Dcom.sun.management.jmxremote.local.only=false
-Dcom.sun.management.jmxremote.authenticate=false
-Dcom.sun.management.jmxremote.ssl=false

# Flight Recorder (for production profiling)
-XX:StartFlightRecording=dumponexit=true,filename=/var/log/aurigraph/flight-recording.jfr,maxsize=1024m,maxage=24h

# Enable detailed GC statistics
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+PrintGCTimeStamps
-XX:+PrintTenuringDistribution
-XX:+PrintGCApplicationStoppedTime

# =============================================================================
# 10. NUMA OPTIMIZATION (Multi-socket systems)
# =============================================================================

# Enable NUMA awareness (improves memory locality)
-XX:+UseNUMA

# Interleave memory across NUMA nodes
-XX:+UseNUMAInterleaving

# =============================================================================
# 11. SECURITY OPTIMIZATIONS
# =============================================================================

# Stronger secure random number generation
-Djava.security.properties=/etc/aurigraph/java.security

# Disable weak cryptographic algorithms
-Djdk.tls.disabledAlgorithms=SSLv3,TLSv1,TLSv1.1,RC4,DES,MD5withRSA

# =============================================================================
# 12. DEVELOPMENT-SPECIFIC FLAGS
# =============================================================================

# Use when profiling with async-profiler
# -XX:+UnlockDiagnosticVMOptions
# -XX:+DebugNonSafepoints
# -XX:+PreserveFramePointer

# Use for debugging OOM issues
# -XX:+HeapDumpOnOutOfMemoryError
# -XX:HeapDumpPath=/var/log/aurigraph/heapdump.hprof

# =============================================================================
# 13. PRODUCTION DEPLOYMENT COMMAND
# =============================================================================

# Full command line for starting Aurigraph V11 with optimizations:
#
# java \
#   @jvm-optimization-config.properties \
#   -jar target/quarkus-app/quarkus-run.jar
#
# Or for native executable:
#
# ./target/*-runner \
#   $(grep -v '^#' jvm-optimization-config.properties | grep -v '^-Dquarkus' | xargs)

# =============================================================================
# 14. EXPECTED PERFORMANCE IMPACT
# =============================================================================

# Optimization Summary:
# - G1GC Tuning:           -10ms GC pause, -0.2GB memory
# - Heap Optimization:     -0.3GB memory, +5% throughput
# - JIT Optimization:      +8% throughput (faster compilation)
# - Virtual Threads:       -25% CPU overhead (already implemented)
# - NUMA Optimization:     +3% throughput (multi-socket only)
# - Network Optimization:  +2% throughput (reduced allocations)
#
# Total Expected Impact:   +18% TPS → 3.54M TPS
# Combined with code optimizations (+42%): 4.26M TPS

# =============================================================================
# 15. VALIDATION CHECKLIST
# =============================================================================

# Before deployment:
# [ ] Baseline performance measured (3.0M TPS confirmed)
# [ ] GC logs enabled and monitored
# [ ] JMX monitoring configured
# [ ] Heap dump path writable
# [ ] Flight Recorder enabled for profiling
# [ ] Native compilation successful (if using native mode)
# [ ] Load testing completed with new flags
# [ ] No performance regression from baseline
# [ ] Memory usage within 2GB target
# [ ] CPU utilization within 60% target

# =============================================================================
# 16. ROLLBACK PLAN
# =============================================================================

# If performance degrades, revert to Sprint 5 baseline JVM flags:
#
# java \
#   -Xms2g -Xmx4g \
#   -XX:+UseG1GC \
#   -XX:MaxGCPauseMillis=200 \
#   -jar target/quarkus-app/quarkus-run.jar

# =============================================================================
# END OF JVM OPTIMIZATION CONFIGURATION
# =============================================================================

# Version: 1.0
# Status: Ready for Testing
# Last Updated: November 4, 2025
# Next Review: After Sprint 15 Phase 2 (Day 4)
